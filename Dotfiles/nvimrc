" bundles {{{

call plug#begin('~/.nvim/plugged')

Plug 'Konfekt/FastFold'
Plug 'Raimondi/delimitMate'
Plug 'airblade/vim-rooter'
Plug 'bling/vim-airline'
Plug 'ervandew/supertab'
Plug 'pbrisbin/vim-mkdir'
Plug 'scrooloose/nerdtree'
Plug 'thinca/vim-visualstar'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'

Plug 'haya14busa/incsearch.vim',  { 'on': '<Plug>(incsearch-' }
Plug 'junegunn/goyo.vim',         { 'on': 'Goyo' }
Plug 'junegunn/limelight.vim',    { 'on': 'Limelight' }
Plug 'rhysd/clever-f.vim',        { 'on': '<Plug>(clever-f-' }
Plug 'tpope/vim-commentary',      { 'on': '<Plug>Commentary' }

" OSX only
if system("uname -s") == "Darwin\n"
  Plug 'airblade/vim-gitgutter'
  Plug 'benekastah/neomake'
endif

" TMUX only
if $TMUX != ""
  Plug 'christoomey/vim-tmux-navigator'
  Plug 'sjl/tslime.vim'
endif

" external FZF
if isdirectory('/usr/local/Cellar/fzf/0.9.0/')
  Plug '/usr/local/Cellar/fzf/0.9.0/'
endif

" custom syntax bundles
Plug 'Keithbsmiley/swift.vim',       { 'for': 'swift' }
Plug 'b4winckler/vim-objc',          { 'for': 'objc' }
Plug 'briancollins/vim-jst',         { 'for': 'jst' }
Plug 'davidoc/taskpaper.vim',        { 'for': 'taskpaper' }
Plug 'elzr/vim-json',                { 'for': 'json' }
Plug 'groenewege/vim-less',          { 'for': 'less' }
Plug 'jelera/vim-javascript-syntax', { 'for': 'javascript' }
Plug 'kchmck/vim-coffee-script',     { 'for': 'coffeescript' }
Plug 'moll/vim-node',                { 'for': 'javascript' }
Plug 'othree/html5.vim',             { 'for': 'html' }
Plug 'pangloss/vim-javascript',      { 'for': 'javascript' }
Plug 'plasticboy/vim-markdown',      { 'for': 'markdown' }
Plug 'sophacles/vim-processing',     { 'for': 'processing' }
Plug 'sudar/vim-arduino-syntax',     { 'for': 'arduino' }
Plug 'tikhomirov/vim-glsl',          { 'for': 'glsl' }
Plug 'vim-scripts/ck.vim',           { 'for': 'chuck' }

call plug#end()

" }}}
" nvim settings {{{

" make nvim more useful
set nocompatible

" encoding
set encoding=utf-8
set fileencodings=utf-8

" yank and paste with system clipboard
set clipboard=unnamed

" watch for file changes
set autoread

" show long lines
set display+=lastline

" redraw only when needed and fast tty
set lazyredraw
set ttyfast
set ttyscroll=3

" fast timeouts
set notimeout
set ttimeout
set ttimeoutlen=100

" don't beep
set noeb vb t_vb=

" disable startup message
set shortmess+=I

" syntax coloring
syntax enable

" color theme
set t_Co=256
set background=dark

" solarized
let g:solarized_bold=0
let g:solarized_italic=0
let g:solarized_underline=0
let g:solarized_menu=0
let g:solarized_contrast="high"
let g:solarized_visibility="normal"
colorscheme solarized

" highlight 80 character
" set textwidth=80
" set colorcolumn=+1

" disable background color erase so that color scheme work properly in tmux
set t_ut=

" don't try to highlight longer lines
" set synmaxcol=1024

" indentation
filetype plugin indent on
set autoindent
set tabstop=2
set shiftwidth=2
set softtabstop=2
set shiftround
set expandtab
set breakindent

" leader
let mapleader=";"

" additional settings
set backspace=indent,eol,start
set nonumber
set linebreak
set ruler
set sidescrolloff=6
set gdefault
set virtualedit=block

let g:default_scrolloff=3
exe "set scrolloff=" . g:default_scrolloff

" path used by gf, :find, etc..
set path=.,**

" don't complete 'included files', speeds things up
set complete-=i

" hidden chars liketextmate, disabled by default
set list
" set listchars=tab:â–¸\ ,trail:âˆ™,eol:Â¬
set listchars=tab:â–¸\ ,trail:âˆ™

" buffers/tabs settings
set switchbuf=useopen,usetab,newtab
set hidden

" no backups or swapfiles, with centralized and persistent undo history
set nobackup
set noswapfile
set undofile
set undodir=~/.nvim/undo//

" fix for node fs.watch
set backupcopy=yes

" long history and undo
set history=1000
set undolevels=1000
set undoreload=10000

" search settings
set hlsearch
set ignorecase
set smartcase
set incsearch

" always disaplay status line
set laststatus=2

" show tabline only when needed
set showtabline=1

" don't show current mode/cmd
set noshowmode
set noshowcmd

" completion in command line
set wildmenu

" insert completion height
set pumheight=10

" open splits to the right and bottom
set splitright
set splitbelow

" fillchars with nice utf8 vert split, and no fold char
set fillchars=fold:\ ,vert:â”‚

" extended % matching, load only if no newer matchit found
if !exists("g:loaded_matchit") && findfile("plugin/matchit.vim", &rtp) ==# ""
  runtime! macros/matchit.vim
endif

" set path
if system("uname")=="Darwin\n"
  let $PATH="/usr/local/bin:" . $PATH . ":/Users/Szymon/Dropbox/Code/Scripts"
endif

" code folding
set foldmethod=syntax
set foldlevelstart=99
set foldcolumn=0

" nice fold text modified from: https://coderwall.com/p/usd_cw
set foldtext=FoldText()
function! FoldText()
  let l:lpadding = &fdc
  redir => l:signs
    execute "silent sign place buffer=" . bufnr("%")
  redir End
  let l:lpadding += l:signs =~ "id=" ? 2 : 0

  if exists("+relativenumber")
    if (&number)
      let l:lpadding += max([&numberwidth, strlen(line("$"))]) + 1
    elseif (&relativenumber)
      let l:lpadding += max([&numberwidth, strlen(v:foldstart - line("w0")), strlen(line("w$") - v:foldstart), strlen(v:foldstart)]) + 1
    endif
  else
    if (&number)
      let l:lpadding += max([&numberwidth, strlen(line("$"))]) + 1
    endif
  endif

  let l:start = substitute(getline(v:foldstart), "\t", repeat(" ", &tabstop), "g")
  let l:end = substitute(substitute(getline(v:foldend), "\t", repeat(" ", &tabstop), "g"), '^\s*', "", "g")

  let l:width = winwidth(0) - l:lpadding

  let l:separator = " ... "
  let l:separatorlen = strlen(substitute(l:separator, ".", "x", "g"))
  let l:start = strpart(l:start , 0, l:width - strlen(substitute(l:end, ".", "x", "g")) - l:separatorlen)
  let l:text = l:start . l:separator . l:end

  return l:text
endfunction

" }}}
" autocommands {{{

" return to same line after reopenning file
augroup line_return
  au!

  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") && !&diff |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" automatically resize splits when resizing window
augroup split_resize
  au!

  au VimResized * wincmd =
augroup END

" aupdate checktime for file re-reads
augroup checktime_update
  au!

  au FocusGained,BufEnter,CursorHold * checktime
augroup END

" extend syntax highlight
augroup extend_syntax
  au!

  au Syntax * call matchadd("Todo", "\W\zs\(ASSUMPTION\)")
augroup END

" set proper syntaxes
augroup detect_syntax
  au!

  " proper filetypes based on name
  au BufNewFile,BufRead *.ck                  set filetype=chuck
  au BufNewFile,BufRead *.frag,*.vert,*.glsl  set filetype=glsl
  au BufNewFile,BufRead *.ino                 set filetype=arduino
  au BufNewFile,BufRead *.m,*.mm              set filetype=objc
  au BufNewFile,BufRead *.md                  set filetype=markdown
  au BufNewFile,BufRead *.pde                 set filetype=processing
  au BufNewFile,BufRead *.swift               set filetype=swift
  au BufNewFile,BufRead *.taskpaper           set filetype=taskpaper
  au BufNewFile,BufRead *.tpl,*.ejs           let b:jst_subtype="html" | set filetype=jst
  au BufNewFile,BufRead ~/Dropbox/Notes/*     set filetype=markdown
augroup END

" custom settings based on filetype
augroup ft_settings
  au!

  " indents, folds, etc
  au FileType coffee     setlocal shiftwidth=2 expandtab
  au FileType vim        setlocal foldmethod=marker foldlevel=0
  au FileType clojure    let b:delimitMate_quotes = "\""
  au FileType javascript call JavaScriptFold() | set foldlevelstart=99
  au FileType taskpaper  setlocal nolist | call taskpaper#fold_projects()
  au FileType text       setlocal nolist
  au FileType markdown   setlocal nolist
  au FileType css        setlocal iskeyword+=-
  au FileType lua        syn region luaFunctionBlock transparent fold matchgroup=luaFunction
        \ start="\<function\>" end ="\<end\>"
        \ contains=ALLBUT,luaTodo,luaSpecial,luaCond,luaCondElseif,luaCondEnd,luaRepeat
augroup END

" auto source files
augroup ft_autosource
  " auto source vimrc
  au BufWritePost .vimrc,vimrc,.gvimrc,gvimrc
        \ so $MYVIMRC |
        \ if has('gui_running') | so $MYGVIMRC | endif |
        \ setlocal foldmethod=marker |
        \ AirlineRefresh

  " auto source tmux
  au BufWritePost .tmux.conf,tmux.conf
        \ call system("tmux source-file ~/.tmux.conf; tmux display-message \"Reloaded!\"")
augroup END

" custom mappings based on filetype
augroup ft_mappings
  au!

  " align paragraph of code
  au FileType clojure nnoremap <buffer> <leader>a :let align_view=winsaveview()<cr>=ip<cr>:call winrestview(align_view)<cr>
augroup END

" quickfix/loclist
augroup quickfix
  au BufWinEnter quickfix setlocal cursorline
augroup END

" }}}
" window titles {{{

" set nice window title
function! DirPath()
  let l:splited = split(expand("%:p"), "/")
  let l:cut = 3
  if len(l:splited) < l:cut
    let cut = len(l:splited)
  endif

  let l:cut = -l:cut

  if len(l:splited) == 0
    return "[No Name]"
  else
    return join(l:splited[l:cut : -1], "/")
  endif
endfunction

function! WindowTitle()
  return "nvim: " . DirPath()
endfunction

" set title on start as simple "nvim"
set title
set titlestring=nvim

" update titlestring with proper title
augroup title_titlestring
  au!
  au BufEnter * let &titlestring = WindowTitle()
augroup END

" only needed in screen
if &term == "screen-256color"
  " screen caption is set by iconstring
  set t_IS=k
  set t_IE=\
  set icon

  augroup title_iconstring
    au!
    au BufEnter * let &iconstring = WindowTitle()
  augroup END

  " screen window title is set by titlestring
  set t_ts=]2;
  set t_fs=\
endif

" }}}
" plugin: airline {{{

augroup airline_plugin
  au!

  au BufEnter * let g:airline_section_y=airline#section#create(["hunks", "branch"])
augroup END

function! AirlineNeomakeStatus()
  let l:counts = neomake#statusline#LoclistCounts()
  let w = get(l:counts, 'W', 0)
  let e = get(l:counts, 'E', 0)

  if w || e
    let result = ''
    if e
      let result .= 'Error: ' . e
      if w
        let result .= ' '
      endif
    endif
    if w
      let result .= 'Warning: ' . w
    endif
    return result
  else
    return ''
  endif
endfunction

" settings
let g:airline_left_sep=""
let g:airline_right_sep=""
let g:airline_inactive_collapse=0
let g:airline#extensions#whitespace#enabled=0
let g:airline#extensions#syntastic#enabled=0
let g:airline#extensions#hunks#enabled=1
let g:airline#extensions#hunks#non_zero_only=1
let g:airline_section_b="%{DirPath()}"
let g:airline_section_c=""
let g:airline_section_x=""
let g:airline_section_y=""
let g:airline_section_warning="%{AirlineNeomakeStatus()}"

" show tabline themed with airline only when needed
if !has("gui_running")
  let g:airline#extensions#tabline#enabled=1
  let g:airline#extensions#tabline#show_buffers=1
  let g:airline#extensions#tabline#show_tab_type=0
  let g:airline#extensions#tabline#tab_min_count=2
  let g:airline#extensions#tabline#show_tab_nr=0
  let g:airline#extensions#tabline#left_sep=""
  let g:airline#extensions#tabline#left_alt_sep=""
  let g:airline#extensions#tabline#right_sep=""
  let g:airline#extensions#tabline#right_alt_sep=""
  let g:airline#extensions#tabline#close_symbol="âœ•"
endif

" remove bold fonts from airline tomorrow theme
let g:airline_theme_patch_func = "AirlineThemePatch"
function! AirlineThemePatch(palette)
  if g:airline_theme == "tomorrow" || g:airline_theme == "solarized"
    let palettes = [a:palette.normal, a:palette.insert, a:palette.replace, a:palette.visual, a:palette.accents]

    for palette in palettes
      for colors in values(palette)
        if len(colors) >= 5
          let colors[4] = "none"
        endif
      endfor
      " let palette.airline_c[3] = "0"
    endfor

    if g:airline_theme == "tomorrow" && !has("gui_running")
      for colors in values(a:palette.inactive)
        let colors[2] = "245"
        let colors[3] = "0"
      endfor
    endif

    if g:airline_theme == "solarized"
      for colors in values(a:palette.inactive)
        if &background == "dark"
          let colors[0] = "#586e75"
          let colors[1] = "#073642"
        else
          let colors[0] = "#93a1a1"
          let colors[1] = "#eee8d5"
        endif
        let colors[2] = "10"
        let colors[3] = "0"
      endfor
    endif
  endif
endfunction

" }}}
" plugin: nerdtree {{{

let NERDTreeMinimalUI=1
let NERDTreeDirArrows=1
let NERDTreeMapActivateNode='e'

nnoremap <silent> <c-n> :NERDTree<cr>
nnoremap <silent> <c-f> :e .<cr>

" }}}
" plugin: gitgutter {{{

let g:gitgutter_signs=0
let g:gitgutter_realtime=0
let g:gitgutter_eager=0
let g:gitgutter_max_signs=1000

" }}}
" plugin: neomake {{{

augroup neomake_plugin
  au!

  au BufReadPost,BufWritePost *.js Neomake
augroup END

let g:neomake_place_signs=0

" }}}
" plugin: delimitmate {{{

let g:delimitMate_balance_matchpairs=1
let g:delimitMate_expand_cr=1
let g:delimitMate_expand_space=1

" }}}
" plugin: supertab {{{

let g:SuperTabDefaultCompletionType="context"
let g:SuperTabContextDefaultCompletionType="<c-n>"

" silent input maps
inoremap <script> <silent> <Plug>SuperTabForward <c-r>=SuperTab('n')<cr>
inoremap <script> <silent> <Plug>SuperTabBackward <c-r>=SuperTab('p')<cr>

" }}}
" plugin: fzf {{{

function! BuffersList()
  let l:all = range(0, bufnr('$'))
  let l:list = []

  for l:buffer in l:all
    if buflisted(l:buffer) && index(l:list, bufname(l:buffer)) == -1
      call add(l:list, bufname(l:buffer))
    endif
  endfor

  return list
endfunction

function! AgHandler(l)
  let keys = split(a:l, ':')
  execute 'tabe +' . keys[-2] . ' ' . escape(keys[-1], ' ')
endfunction

function! AgSearchHandler()
  let a:search = input("Grep for: ")
  return "ag -i " . a:search . " | sed 's@\\(.[^:]*\\):\\(.[^:]*\\):\\(.*\\)@\\3:\\2:\\1@' "
endfunction

function! OpenNote(l)
  execute 'e ~/Dropbox/Notes/' . escape(a:l, ' ') . '.txt'
endfunction

function! OpenTask(l)
  execute 'e ~/Dropbox/Tasks/' . escape(a:l, ' ') . '.taskpaper'
endfunction

command! FZFAg call fzf#run({
      \ 'source': AgSearchHandler(),
      \ 'sink': function('AgHandler'),
      \ 'options': '-m',
      \ 'tmux_height': '40%'
      \ })

command! FZFBuffers call fzf#run({
      \ 'source': reverse(BuffersList()),
      \ 'sink': 'e ',
      \ 'tmux_height': '40%'
      \ })

command! FZFMru call fzf#run({
      \ 'source': v:oldfiles,
      \ 'sink': 'e ',
      \ 'tmux_height': '40%'
      \ })

command! FZFNotes call fzf#run({
      \ 'source': 'find ~/Dropbox/Notes -iname "*.txt" | cut -d "/" -f6 | sed "s/\.txt$//"',
      \ 'sink': function('OpenNote'),
      \ 'tmux_height': '40%'
      \ })

command! FZFTasks call fzf#run({
      \ 'source': 'find ~/Dropbox/Tasks -iname "*.taskpaper" | cut -d "/" -f6 | sed "s/\.taskpaper$//"',
      \ 'sink': function('OpenTask'),
      \ 'tmux_height': '40%'
      \ })

nnoremap <silent> <c-p>      :FZF<cr>
nnoremap <silent> <c-b>      :FZFBuffers<cr>
nnoremap <silent> <leader>fg :FZFAg<cr>
nnoremap <silent> <leader>fm :FZFMru<cr>

if isdirectory($HOME . "/Dropbox/Notes")
  nnoremap <silent> <leader>fn :FZFNotes<cr>
endif

if isdirectory($HOME . "/Dropbox/Tasks")
  nnoremap <silent> <leader>ft :FZFTasks<cr>
endif

" }}}
" plugin: tslime {{{

let g:tslime_ensure_trailing_newlines=1

" }}}
" plugin: limelight {{{

let g:limelight_conceal_ctermfg = 10
let g:limelight_conceal_guifg = "#586e75"

" }}}
" plugin: goyo {{{

function! GoyoBefore()
  if !has("gui_running")
    set showtabline=0
  endif

  if $TMUX != ""
    silent !tmux set status off > /dev/null
    silent !tmux resize-pane -Z > /dev/null
  endif

  set scrolloff=999
  Limelight
endfunction

function! GoyoAfter()
  if !has("gui_running")
    set showtabline=1
  endif

  if $TMUX != ""
    silent !tmux set status on > /dev/null
    silent !tmux resize-pane -Z > /dev/null
  endif

  exe "set scrolloff=" . g:default_scrolloff
  Limelight!
endfunction

let g:goyo_callbacks=[ function('GoyoBefore'), function('GoyoAfter') ]
let g:goyo_width=120

command! Zen :Goyo

nnoremap <silent> <leader>Z :Zen<cr>

" }}}
" plugin: json {{{

let g:vim_json_syntax_conceal=0

" }}}
" plugin: clever-f {{{

let g:clever_f_across_no_line=1
let g:clever_f_chars_match_any_signs=""
let g:clever_f_fix_key_direction=1
let g:clever_f_smart_case=1

nmap f <Plug>(clever-f-f)
xmap f <Plug>(clever-f-f)
omap f <Plug>(clever-f-f)
nmap F <Plug>(clever-f-F)
xmap F <Plug>(clever-f-F)
omap F <Plug>(clever-f-F)
nmap t <Plug>(clever-f-t)
xmap t <Plug>(clever-f-t)
omap t <Plug>(clever-f-t)
nmap T <Plug>(clever-f-T)
xmap T <Plug>(clever-f-T)
omap T <Plug>(clever-f-T)

" }}}
" plugin: incsearch {{{

map / <Plug>(incsearch-forward)
map ? <Plug>(incsearch-backward)

" }}}
" plugin: rooter {{{

let g:rooter_use_lcd = 1
let g:rooter_patterns = [ ".git/", "node_modules/", "package.json" ]

" }}}
" plugin: taskpaper {{{

let g:task_paper_date_format = "%Y-%m-%d"
let g:task_paper_styles={ "today": "ctermfg=DarkGreen" }

" }}}
" plugin: commentary {{{

map  gc  <Plug>Commentary
nmap gcc <Plug>CommentaryLine

" }}}
" custom abbrevs {{{

iabbrev <silent> _date <c-r>=strftime("%Y-%m-%d")<cr>
iabbrev <silent> _time <c-r>=strftime("%H:%M")<cr>

function! EatChar(pat)
  let c = nr2char(getchar(0))
  return (c =~ a:pat) ? '' : c
endfunction

function! SpacelessIabbrev(from, to)
  execute "iabbrev <silent> <buffer> " . a:from . " " . a:to . "<c-r>=EatChar('\\s')<cr>"
endfunction

" based on filetype
augroup ft_abbrev
  au!

  au FileType taskpaper :iabbrev <buffer> @tomorrow @due(<c-r>=strftime("%Y-%m-%d", localtime() + 86400)<cr>)

  au FileType javascript
        \ :call SpacelessIabbrev("clog", "console.log") |
        \ :call SpacelessIabbrev("fn", "function")
augroup END

" open help in new vertical split
cnoreabbrev <expr> h ((getcmdtype() == ':' && getcmdpos() <= 2) ? 'vert h' : 'h')

" }}}
" custom commands {{{

" kills trailing whitespaces
command! KillWhitespace :normal :%s/\s\+$//g<cr>

" shows syntax highlight group for element
function! ShowSyntax()
  echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), " > ")
endfunc

command! ShowSyntax :call ShowSyntax()

" destroy all buffers that are not open in any tabs or windows
" https://github.com/artnez/vim-wipeout/blob/master/plugin/wipeout.vim
function! Wipeout(bang)
  " figure out which buffers are visible in any tab
  let visible={}
  for t in range(1, tabpagenr("$"))
    for b in tabpagebuflist(t)
      let visible[b]=1
    endfor
  endfor
  " close any buffer that are loaded and not visible
  let l:tally=0
  let l:cmd="bw"
  if a:bang
    let l:cmd .= "!"
  endif
  for b in range(1, bufnr("$"))
    if buflisted(b) && !has_key(visible, b)
      let l:tally += 1
      exe l:cmd . " " . b
    endif
  endfor
  echon "Deleted " . l:tally . " buffer" . (l:tally == 1 ? "" : "s")
endfun

command! -bang Wipeout :call Wipeout(<bang>0)

" open URL in browser
if system("uname -s") == "Darwin\n"
  function! s:OpenURL(url)
    echo a:url
    exe "!open \"" . a:url . "\" > /dev/null"
    redraw!
  endfunction

  command! -nargs=1 OpenURL :silent call s:OpenURL(<q-args>)

  nnoremap gx :OpenURL <cfile><cr>
endif

" proper indentation on i
function! InsertIndent()
  if len(getline('.')) == 0
    return "cc"
  else
    return "i"
  endif
endfunction

nnoremap <expr> i InsertIndent()

" rename current file
function! Rename()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction

command! Rename :call Rename()

" tab to space and back
command! TabToSpace :setlocal expandtab | %retab!
command! SpaceToTab :setlocal noexpandtab | %retab!

" }}}
" custom mappings {{{

" expand %% to directory of current file in command-line mode
cnoremap %% <c-r>=fnameescape(expand("%:~:h"))<cr>/

" tab as %
map <tab> %

" input mode mappings
inoremap <c-a> <c-o>0
inoremap <c-e> <c-o>$

" proper movement
nnoremap <Left>  <nop>
nnoremap <Right> <nop>
nnoremap <Up>    <nop>
nnoremap <Down>  <nop>
inoremap <Left>  <nop>
inoremap <Right> <nop>
inoremap <Up>    <nop>
inoremap <Down>  <nop>

" key repeat hack for resizing splits
nmap <c-w>+ <c-w>+<sid>ws
nmap <c-w>- <c-w>-<sid>ws
nmap <c-w>> <c-w>><sid>ws
nmap <c-w>< <c-w><<sid>ws
nnoremap <script> <sid>ws+ <c-w>+<sid>ws
nnoremap <script> <sid>ws- <c-w>-<sid>ws
nnoremap <script> <sid>ws> <c-w>><sid>ws
nnoremap <script> <sid>ws< <c-w><<sid>ws
nmap <sid>ws <nop>

" move by screen lines using arrow, unless it's with number
nnoremap <expr> k (v:count ? 'k' : 'gk')
nnoremap <expr> j (v:count ? 'j' : 'gj')

" quicker indentation
nnoremap > >>
nnoremap < <<

" dont loose selection on indenting
vnoremap > >gv
vnoremap < <gv

" dot works in visual selection mode!
vnoremap . :norm.<cr>

" D deletes to the end of the line
nnoremap D d$

" Y yanks to the end of the line
nnoremap Y y$

" better line begin (H) and end (L)
noremap H ^
noremap L $
vnoremap L g_

" keep search matches in the middle of the window
nnoremap n nzzzv
nnoremap N Nzzzv

" same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz
nnoremap <c-o> <c-o>zz

" disable EX mode and other accidental q* commands
nnoremap q/ <nop>
nnoremap q: <nop>
nnoremap q? <nop>

" disable man pages
nnoremap K <nop>
vnoremap K <nop>

" apply macros with Q
nnoremap Q @q
vnoremap Q :norm @q<cr>

" open common files
nnoremap <leader>ov :e ~/.nvimrc<cr>
nnoremap <leader>oz :e ~/.zshrc<cr>

if system("uname -s") == "Darwin\n"
  nnoremap <leader>od :e ~/Dropbox/Notes/drafts.txt<cr>
  nnoremap <leader>ot :e ~/Dropbox/Tasks/Current.taskpaper<cr>
endif

" open file in current directory
nnoremap <leader>of :e <c-r>=expand("%:p:h") . "/"<cr>

" run current line in shell
nnoremap <leader>rs yyp!!sh<cr>

" save and diff changes
nnoremap <leader>w :w !diff % -<cr>

" buffers
nnoremap gb :bnext<cr>
nnoremap gB :bprev<cr>
nnoremap <leader>bd :bdelete!<cr>
nnoremap <leader>B :enew<cr>

" new tab
nnoremap <leader>T :tabnew<cr>

" select whole buffer
nnoremap <leader>va ggVG

" select last paste in visual mode
nnoremap <leader>vp '`[' . strpart(getregtype(), 0, 1) . '`]'

" yank whole buffer
nnoremap <leader>ya :let yank_view=winsaveview()<cr>ggyG<cr>:call winrestview(yank_view)<cr>

" close everything but current fold
nnoremap <leader>ff :setlocal foldlevel=0<cr>zA<cr>

" kill whitespace
nnoremap <silent> <leader>k :let kill_view=winsaveview()<cr>:KillWhitespace<cr>:nohlsearch<cr>:call winrestview(kill_view)<cr>

" clean current search
nnoremap <silent> <leader>c :nohlsearch<cr>

" toggle list chars
nnoremap <silent> <leader>l :set list!<cr>

" toggle numbers
nnoremap <silent> <leader>n :set number!<cr>

" align block
nnoremap <leader>a :let align_view=winsaveview()<cr>=i}<cr>:call winrestview(align_view)<cr>

" center on cursor using scrollof
nnoremap <silent> <leader>z :let &scrolloff=999-&scrolloff<cr>

" paste from system clipboard
nnoremap <leader>p "+p<cr>

" jump to errors
nnoremap <leader>e :lnext<cr>
nnoremap <leader>E :lprevious<cr>

" }}}
