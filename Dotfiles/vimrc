" bundles {{{

call plug#begin('~/.vim/plugged')

Plug 'Konfekt/FastFold'
Plug 'Raimondi/delimitMate'
Plug 'airblade/vim-rooter'
Plug 'ajh17/VimCompletesMe'
Plug 'bling/vim-airline'
Plug 'christoomey/vim-tmux-navigator'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'

Plug 'epeli/slimux',                     { 'on': [ 'SlimuxREPLSendLine', 'SlimuxREPLSendSelection', 'SlimuxREPLConfigure' ] }
Plug 'junegunn/goyo.vim',                { 'on': 'Goyo' }
Plug 'junegunn/limelight.vim',           { 'on': 'Limelight' }
Plug 'junegunn/rainbow_parentheses.vim', { 'on': [ 'RainbowParentheses', 'RainbowParenthesesToggle' ] }
Plug 'junegunn/vim-easy-align',          { 'on': [ '<Plug>(EasyAlign)', 'EasyAlign' ] }
Plug 'mbbill/undotree',                  { 'on': 'UndotreeToggle' }
Plug 'rhysd/clever-f.vim',               { 'on': '<Plug>(clever-f-' }
Plug 'tpope/vim-commentary',             { 'on': '<Plug>Commentary' }

" OSX only
if has("mac")
  Plug 'scrooloose/syntastic'
  Plug 'airblade/vim-gitgutter'
endif

" Homebrew FZF
if isdirectory('/usr/local/Cellar/fzf/0.9.3/')
  Plug '/usr/local/Cellar/fzf/0.9.3/'
endif

" AUR FZF
if isdirectory('/usr/share/vim/vimfiles/plugin/fzf.vim')
  Plug '/usr/share/vim/vimfiles/plugin/fzf.vim'
endif

" custom syntax bundles
Plug 'Keithbsmiley/swift.vim',       { 'for': 'swift' }
Plug 'b4winckler/vim-objc',          { 'for': 'objc' }
Plug 'briancollins/vim-jst',         { 'for': 'jst' }
Plug 'davidoc/taskpaper.vim',        { 'for': 'taskpaper' }
Plug 'elzr/vim-json',                { 'for': 'json' }
Plug 'groenewege/vim-less',          { 'for': 'less' }
Plug 'jelera/vim-javascript-syntax', { 'for': 'javascript' }
Plug 'kchmck/vim-coffee-script',     { 'for': 'coffee' }
Plug 'moll/vim-node',                { 'for': 'javascript' }
Plug 'othree/html5.vim',             { 'for': 'html' }
Plug 'pangloss/vim-javascript',      { 'for': 'javascript' }
Plug 'tpope/vim-markdown',           { 'for': 'markdown' }
Plug 'sophacles/vim-processing',     { 'for': 'processing' }
Plug 'sudar/vim-arduino-syntax',     { 'for': 'arduino' }
Plug 'tikhomirov/vim-glsl',          { 'for': 'glsl' }
Plug 'vim-scripts/ck.vim',           { 'for': 'chuck' }

call plug#end()

" }}}
" vim settings {{{

" viminfo - more v:oldfiles, register lines
set viminfo='1000,<100,s10,

" encoding
set encoding=utf-8
set fileencodings=utf-8

" yank and paste with system clipboard
set clipboard=unnamed

" watch for file changes
set autoread

" show long lines
set display+=lastline

" redraw only when needed and fast tty
set lazyredraw

if !has("nvim")
  set ttyfast
  set ttyscroll=3
endif

" fast timeoute
set notimeout
set ttimeout
set ttimeoutlen=100

" don't beep
set noeb vb t_vb=

" disable startup message
set shortmess+=I

" syntax coloring
syntax enable

" color theme
set t_Co=256
set background=dark

" solarized
let g:solarized_bold=0
let g:solarized_italic=0
let g:solarized_underline=0
let g:solarized_menu=0
let g:solarized_contrast="high"
let g:solarized_visibility="normal"
colorscheme solarized

" jellybeans
" colorscheme jellybeans

" highlight 80 character
" set textwidth=80
" set colorcolumn=+1

" disable background color erase so that color scheme work properly in tmux
set t_ut=

" don't try to highlight longer lines
" set synmaxcol=1024

" indentation
filetype plugin indent on
set autoindent
set tabstop=2
set shiftwidth=2
set softtabstop=2
set shiftround
set expandtab
set breakindent

" leader
let mapleader=";"

" additional settings
set backspace=indent,eol,start
set nonumber
set linebreak
set ruler
set sidescrolloff=6
set gdefault
set virtualedit=block

let g:default_scrolloff=3
exe "set scrolloff=" . g:default_scrolloff

" path used by gf, :find, etc..
set path+=./**

" don't complete 'included files', speeds things up
set complete-=i

" hidden chars liketextmate, disabled by default
set list
set listchars=tab:▸\ ,trail:∙

" buffers/tabs settings
set switchbuf=useopen,usetab,newtab
set hidden

" no backups or swapfiles, with centralized and persistent undo history
set nobackup
set noswapfile
set undofile
set undodir=~/.vim/undo//

" fix for node fs.watch
set backupcopy=yes

" long history and undo
set history=1000
set undolevels=1000
set undoreload=10000

" search settings
set hlsearch
set ignorecase
set smartcase
set incsearch

" always disaplay status line
set laststatus=2

" show tabline only when needed
set showtabline=2

" don't show current mode/cmd
set noshowmode
set noshowcmd

" completion in command line
set wildmenu

" insert completion height
set pumheight=10

" open splits to the right and bottom
set splitright
set splitbelow

" fillchars with nice utf8 vert split, and no fold char
set fillchars=fold:\ ,vert:│

" grep
set grepprg=ag\ --vimgrep\ $*
set grepformat=%f:%l:%c:%m

" extended % matching, load only if no newer matchit found
if !exists("g:loaded_matchit") && findfile("plugin/matchit.vim", &rtp) ==# ""
  runtime! macros/matchit.vim
endif

" set path
if has("mac")
  let $PATH="/usr/local/bin:" . $PATH . ":/Users/Szymon/Dropbox/Code/Scripts"
endif

" code folding
set foldmethod=syntax
set foldlevelstart=99
set foldcolumn=0

" nice fold text modified from: https://coderwall.com/p/usd_cw
set foldtext=FoldText()
function! FoldText()
  let l:lpadding=&fdc
  redir => l:signs
    execute "silent sign place buffer=" . bufnr("%")
  redir End
  let l:lpadding += l:signs =~ "id=" ? 2 : 0

  if exists("+relativenumber")
    if (&number)
      let l:lpadding += max([&numberwidth, strlen(line("$"))]) + 1
    elseif (&relativenumber)
      let l:lpadding += max([&numberwidth, strlen(v:foldstart - line("w0")), strlen(line("w$") - v:foldstart), strlen(v:foldstart)]) + 1
    endif
  else
    if (&number)
      let l:lpadding += max([&numberwidth, strlen(line("$"))]) + 1
    endif
  endif

  let l:start=substitute(getline(v:foldstart), "\t", repeat(" ", &tabstop), "g")
  let l:end=substitute(substitute(getline(v:foldend), "\t", repeat(" ", &tabstop), "g"), '^\s*', "", "g")

  let l:width=winwidth(0) - l:lpadding

  let l:separator=" ... "
  let l:separatorlen=strlen(substitute(l:separator, ".", "x", "g"))
  let l:start=strpart(l:start , 0, l:width - strlen(substitute(l:end, ".", "x", "g")) - l:separatorlen)
  let l:text=l:start . l:separator . l:end

  return l:text
endfunction

" }}}
" autocommands {{{

" return to same line after reopenning file
augroup line_return
  au!

  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") && !&diff |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" automatically resize splits when resizing window
augroup split_resize
  au!

  au VimResized * wincmd =
augroup END

" aupdate checktime for file re-reads
augroup checktime_update
  au!

  au FocusGained,BufEnter,CursorHold * checktime
augroup END

" extend syntax highlight
augroup extend_syntax
  au!

  au Syntax * call matchadd("Todo", "\W\zs\(ASSUMPTION\)")
augroup END

" set proper syntaxes
augroup detect_syntax
  au!

  au BufNewFile,BufRead *.ck                 set filetype=chuck
  au BufNewFile,BufRead *.frag,*.vert,*.glsl set filetype=glsl
  au BufNewFile,BufRead *.ino                set filetype=arduino
  au BufNewFile,BufRead *.m,*.mm             set filetype=objc
  au BufNewFile,BufRead *.md                 set filetype=markdown
  au BufNewFile,BufRead *.pde                set filetype=processing
  au BufNewFile,BufRead *.swift              set filetype=swift
  au BufNewFile,BufRead *.taskpaper          set filetype=taskpaper
  au BufNewFile,BufRead *.tpl,*.ejs          let b:jst_subtype="html" | set filetype=jst
  au BufNewFile,BufRead ~/Dropbox/Notes/*    set filetype=markdown
augroup END

" custom settings based on filetype
augroup ft_settings
  au!

  au FileType css      setlocal iskeyword+=-
  au FileType markdown setlocal nolist
  au FileType text     setlocal nolist
  au FileType vim      setlocal foldmethod=marker foldlevel=0
  au FileType arduino  setlocal commentstring=//\ %s

  au FileType clojure
        \ nnoremap <buffer> <leader>a :let align_view=winsaveview()<cr>=ip<cr>:call winrestview(align_view)<cr>

  au FileType taskpaper
        \ setlocal nolist |
        \ call taskpaper#fold_projects() |
        \ nnoremap <buffer> <leader>to :g/@today/foldopen<cr>:nohlsearch<cr>gg

  au FileType processing
        \ setlocal makeprg=processing\ %:p:h |
        \ setlocal errorformat=%DEntering\ directory\ \"%f\",%f:%l:%c:%*\\d:%*\\d:\ %m,%-G%.%#

  au FileType javascript
        \ call JavaScriptFold() |
        \ set foldlevelstart=99 |
        \ setlocal suffixesadd=.js |
        \ setlocal makeprg=javascript\ %

  au FileType lua
        \ syn region luaFunctionBlock transparent fold matchgroup=luaFunction
        \ start="\<function\>" end ="\<end\>"
        \ contains=ALLBUT,luaTodo,luaSpecial,luaCond,luaCondElseif,luaCondEnd,luaRepeat

  au FileType clojure
        \ let b:delimitMate_quotes="\"" |
        \ RainbowParentheses
augroup END

" quickfix/loclist
augroup quickfix
  au!

  au BufWinEnter quickfix setlocal cursorline

  " automatically open quickfix / loclist
  au QuickFixCmdPost grep,make,grepadd,vimgrep,vimgrepadd,cscope,cfile,cgetfile,caddfile,helpgrep cwindow
  au QuickFixCmdPost lgrep,lmake,lgrepadd,lvimgrep,lvimgrepadd,lfile,lgetfile,laddfile            lwindow
augroup END

" }}}
" window titles {{{

" set nice window title
function! DirPath()
  let l:splited=split(expand("%:p"), "/")
  let l:cut=3

  if len(l:splited) < l:cut
    let cut=len(l:splited)
  endif

  let l:cut=-l:cut

  if len(l:splited) == 0
    return "[No Name]"
  else
    return join(l:splited[l:cut : -1], "/")
  endif
endfunction

function! WindowTitle()
  return "vim: " . DirPath()
endfunction

" set title on start as simple "vim"
set title
set titlestring=vim

" update titlestring with proper title
augroup title_titlestring
  au!

  au BufEnter * let &titlestring=WindowTitle()
augroup END

" only needed in screen
if &term == "screen-256color"
  " screen caption is set by iconstring
  set t_IS=k
  set t_IE=\
  set icon

  augroup title_iconstring
    au!

    au BufEnter * let &iconstring=WindowTitle()
  augroup END

  " screen window title is set by titlestring
  set t_ts=]2;
  set t_fs=\
endif

" }}}
" plugin: airline {{{

augroup airline_plugin
  au!

  au BufEnter * let g:airline_section_y=airline#section#create(["hunks", "branch"])
augroup END

" settings
let g:airline_left_sep=""
let g:airline_right_sep=""
let g:airline_inactive_collapse=0
let g:airline#extensions#whitespace#enabled=0
let g:airline#extensions#syntastic#enabled=1
let g:airline#extensions#hunks#enabled=1
let g:airline#extensions#hunks#non_zero_only=1
let g:airline_section_b="%{DirPath()}"
let g:airline_section_c=""
let g:airline_section_x=""
let g:airline_section_y=""

" show tabline themed with airline only when needed
if !has("gui_running")
  let g:airline#extensions#tabline#enabled=1
  let g:airline#extensions#tabline#show_buffers=1
  let g:airline#extensions#tabline#show_tab_type=0
  let g:airline#extensions#tabline#tab_min_count=2
  let g:airline#extensions#tabline#show_tab_nr=0
  let g:airline#extensions#tabline#left_sep=""
  let g:airline#extensions#tabline#left_alt_sep=""
  let g:airline#extensions#tabline#right_sep=""
  let g:airline#extensions#tabline#right_alt_sep=""
  let g:airline#extensions#tabline#close_symbol="✕"
endif

" patch function
let g:airline_theme_patch_func="AirlineThemePatch"

function! AirlineThemePatch(palette)
  if g:airline_theme == "tomorrow" || g:airline_theme == "solarized" || g:airline_theme == "jellybeans"
    let l:palettes=[a:palette.normal, a:palette.insert, a:palette.replace, a:palette.visual, a:palette.accents]

    for l:palette in l:palettes
      for l:colors in values(l:palette)
        if len(l:colors) >= 5
          let l:colors[4]="none"
        endif
      endfor
    endfor

    if g:airline_theme == "tomorrow" && !has("gui_running")
      for l:colors in values(a:palette.inactive)
        let l:colors[2]="245"
        let l:colors[3]="0"
      endfor
    endif

    if g:airline_theme == "solarized"
      for l:colors in values(a:palette.inactive)
        if &background == "dark"
          let l:colors[0]="#586e75"
          let l:colors[1]="#073642"
        else
          let l:colors[0]="#93a1a1"
          let l:colors[1]="#eee8d5"
        endif
        let l:colors[2]="10"
        let l:colors[3]="0"
      endfor
    endif

    if g:airline_theme == "jellybeans"
      for l:palette in l:palettes
        for l:colors in values(l:palette)
          if len(l:colors) >= 3 && l:colors[3] == "233"
            let l:colors[3]="234"
          endif
        endfor
      endfor
    endif
  endif
endfunction

" }}}
" plugin: netrw {{{

augroup netrw_plugin
  au!

  au FileType netrw
        \ map <buffer> <silent> e <cr> |
        \ map <buffer> <silent> u - |
        \ map <buffer> <silent> N %
augroup END

let g:netrw_banner=0

nnoremap <silent> <c-f> :Explore<cr>

" }}}
" plugin: gitgutter {{{

let g:gitgutter_signs=0
let g:gitgutter_realtime=0
let g:gitgutter_eager=0
let g:gitgutter_max_signs=1000
let g:gitgutter_map_keys=0
let g:gitgutter_escape_grep=1

" }}}
" plugin: syntastic {{{

let g:syntastic_enable_signs=0
let g:syntastic_enable_highlighting=0
let g:syntastic_check_on_open=0
let g:syntastic_check_on_wq=0
let g:syntastic_cursor_column=0
let g:syntastic_always_populate_loc_list=1
let g:syntastic_auto_loc_list=1
let g:syntastic_error_symbol="!"
let g:syntastic_style_error_symbol="!"
let g:syntastic_warning_symbol="?"
let g:syntastic_style_warning_symbol="?"
let g:syntastic_stl_format="%E{Error: %e}%B{ }%W{Warning: %w}"

" }}}
" plugin: delimitmate {{{

let g:delimitMate_balance_matchpairs=1
let g:delimitMate_expand_cr=1
let g:delimitMate_expand_space=1

" }}}
" plugin: supertab {{{

let g:SuperTabDefaultCompletionType="context"
let g:SuperTabContextDefaultCompletionType="<c-n>"

" silent input maps
inoremap <script> <silent> <Plug>SuperTabForward <c-r>=SuperTab("n")<cr>
inoremap <script> <silent> <Plug>SuperTabBackward <c-r>=SuperTab("p")<cr>

" }}}
" plugin: fzf {{{

function! BuffersList()
  let l:all=range(0, bufnr("$"))
  let l:list=[]

  for l:buffer in l:all
    let l:bufname=bufname(l:buffer)
    if buflisted(l:buffer) && index(l:list, l:bufname) == -1 && strlen(l:bufname) > 1
      call add(l:list, l:bufname)
    endif
  endfor

  return list
endfunction

function! AgHandler(e)
  let l:keys=split(a:e, ":")
  let l:line=l:keys[1]
  let l:col =l:keys[2]
  let l:file=escape(l:keys[0], " ")

  execute "tabe +normal\\ " . l:line . "G" . l:col . "|zz " . l:file
endfunction

function! AgSearchVisual()
  let [l:lnum1, l:col1] = getpos("'<")[1:2]
  let [l:lnum2, l:col2] = getpos("'>")[1:2]
  let l:lines = getline(l:lnum1, l:lnum2)
  let l:lines[-1] = l:lines[-1][: l:col2 - (&selection == 'inclusive' ? 1 : 2)]
  let l:lines[0] = l:lines[0][l:col1 - 1:]

  let l:selection = join(l:lines, "\n")

  return AgSearchHandler(l:selection)
endfunction

function! AgSearchSmart()
  let l:word = expand("<cword>")

  if l:word != ""
    return AgSearchHandler(l:word)
  else
    return AgSearchInput()
  endif
endfunction

function! AgSearchInput()
  let l:input = input("Grep for: ")

  return AgSearchHandler(l:input)
endfunction

function! AgSearchHandler(search)
  return "ag --smart-case --nogroup --nocolor --column " . a:search
endfunction

function! BufferLines()
  return map(getline(1, "$"), "printf('%5d  %s', v:key + 1, v:val)")
endfunction

function! BufferLineOpen(e)
  execute "normal! " . matchstr(a:e, "[0-9]\+") . "G"
endfunction

function! Registers()
  let l:regnum =  range(char2nr('a'), char2nr('z'))
  let l:regnum += range(char2nr('0'), char2nr('9'))
  let l:regstr =  [ '"','-','*','%','/','.','#',':' ]
  let l:regnum += map(l:regstr, 'char2nr(v:val)')

  let l:regnum = filter(l:regnum, 'getreg(nr2char(v:val)) !~ "^$"')
  let l:regnum = filter(l:regnum, 'getreg(nr2char(v:val)) !~ "^\s\+$"')

  let l:registers = map(l:regnum, 'getreg(nr2char(v:val))')

  return l:registers
endfunction

function! LineAppend(e)
  execute "normal! o " . a:e
endfunction

function! RecentFiles()
  let l:files = v:oldfiles
  let l:files = filter(l:files, 'v:val !~ "NERD_tree"')
  let l:files = filter(l:files, 'v:val !~ "COMMIT_EDITMSG"')

  return l:files
endfunction

let g:fzf_tmux_height="20%"

command! FZFFiles call fzf#run({
      \ "sink": "e ",
      \ "options": "-m -0",
      \ "tmux_height": g:fzf_tmux_height
      \ })

command! FZFBuffers call fzf#run({
      \ "source": reverse(BuffersList()),
      \ "sink": "e ",
      \ "tmux_height": g:fzf_tmux_height
      \ })

command! FZFMru call fzf#run({
      \ "source": reverse(RecentFiles()),
      \ "sink": "e ",
      \ "options": "-m +s -0",
      \ "tmux_height": g:fzf_tmux_height
      \ })

command! FZFAgInput call fzf#run({
      \ "source": AgSearchSmart(),
      \ "sink": function("AgHandler"),
      \ "options": "-m -0",
      \ "tmux_height": g:fzf_tmux_height
      \ })

command! -range FZFAgVisual call fzf#run({
      \ "source": AgSearchVisual(),
      \ "sink": function("AgHandler"),
      \ "options": "-m -0",
      \ "tmux_height": g:fzf_tmux_height
      \ })

command! FZFLines call fzf#run({
      \ "source": BufferLines(),
      \ "sink": function("BufferLineOpen"),
      \ "options": "+s -0",
      \ "tmux_height": g:fzf_tmux_height
      \ })

command! FZFRegisters call fzf#run({
      \ "source": Registers(),
      \ "sink": function("LineAppend"),
      \ "options": "+s -0",
      \ "tmux_height": g:fzf_tmux_height
      \ })

nnoremap <silent> <c-p>      :FZFFiles<cr>
nnoremap <silent> <c-b>      :FZFBuffers<cr>

nnoremap <silent> <leader>fl :FZFLines<cr>
nnoremap <silent> <leader>fm :FZFMru<cr>
nnoremap <silent> <leader>fh :FZFRegisters<cr>
nnoremap <silent> <leader>fr :FZFRegisters<cr>

nnoremap <silent> <leader>fg :FZFAgInput<cr>
vnoremap <silent> <leader>fg :FZFAgVisual<cr>

if isdirectory($HOME . "/Dropbox/Notes")
  command! FZFNotes call fzf#run({
        \ "source": "find ~/Dropbox/Notes -iname '*.txt' | cut -d '/' -f6 | sed 's/\.txt$//'",
        \ "sink": function("OpenNote"),
        \ "options": "-m",
        \ "tmux_height": g:fzf_tmux_height
        \ })

  function! OpenNote(e)
    execute "e ~/Dropbox/Notes/" . escape(a:e, " ") . ".txt"
  endfunction

  nnoremap <silent> <leader>fn :FZFNotes<cr>
endif

if isdirectory($HOME . "/Dropbox/Tasks")
  command! FZFTasks call fzf#run({
        \ "source": "find ~/Dropbox/Tasks -iname '*.taskpaper' | cut -d '/' -f6 | sed 's/\.taskpaper$//'",
        \ "sink": function("OpenTask"),
        \ "options": "-m",
        \ "tmux_height": g:fzf_tmux_height
        \ })

  function! OpenTask(e)
    execute "e ~/Dropbox/Tasks/" . escape(a:e, " ") . ".taskpaper"
  endfunction

  nnoremap <silent> <leader>ft :FZFTasks<cr>
endif

" }}}
" plugin: limelight {{{

let g:limelight_conceal_ctermfg=10
let g:limelight_conceal_guifg="#586e75"

" }}}
" plugin: goyo {{{

function! GoyoBefore()
  if !has("gui_running")
    set showtabline=0
  endif

  if $TMUX != ""
    silent !tmux set status off > /dev/null
    silent !tmux resize-pane -Z > /dev/null
  endif

  set scrolloff=999
  Limelight
endfunction

function! GoyoAfter()
  if !has("gui_running")
    set showtabline=2
  endif

  if $TMUX != ""
    silent !tmux set status on > /dev/null
    silent !tmux resize-pane -Z > /dev/null
  endif

  exe "set scrolloff=" . g:default_scrolloff
  Limelight!
endfunction

let g:goyo_callbacks=[ function("GoyoBefore"), function("GoyoAfter") ]
let g:goyo_width=120

command! Zen :Goyo

nnoremap <silent> <leader>Z :Zen<cr>

" }}}
" plugin: json {{{

let g:vim_json_syntax_conceal=0

" }}}
" plugin: clever-f {{{

let g:clever_f_across_no_line=1
let g:clever_f_chars_match_any_signs=""
let g:clever_f_fix_key_direction=1
let g:clever_f_smart_case=1

nmap f <Plug>(clever-f-f)
xmap f <Plug>(clever-f-f)
omap f <Plug>(clever-f-f)
nmap F <Plug>(clever-f-F)
xmap F <Plug>(clever-f-F)
omap F <Plug>(clever-f-F)
nmap t <Plug>(clever-f-t)
xmap t <Plug>(clever-f-t)
omap t <Plug>(clever-f-t)
nmap T <Plug>(clever-f-T)
xmap T <Plug>(clever-f-T)
omap T <Plug>(clever-f-T)

" }}}
" plugin: easy-align {{{

vmap <leader>a <Plug>(EasyAlign)
nmap ga        <Plug>(EasyAlign)

" }}}
" plugin: rooter {{{

let g:rooter_use_lcd=1
let g:rooter_patterns=["package.json", "node_modules/", ".git/"]

" }}}
" plugin: taskpaper {{{

let g:task_paper_date_format="%Y-%m-%d"
let g:task_paper_styles={"today": "ctermfg=DarkGreen"}

" }}}
" plugin: commentary {{{

map  gc  <Plug>Commentary
nmap gcc <Plug>CommentaryLine

" }}}
" plugin: slimux {{{

map  <c-c><c-c> :SlimuxREPLSendLine<cr>
vmap <c-c><c-c> :SlimuxREPLSendSelection<cr>

" }}}
" plugin: rainbow parentheses {{{

let g:rainbow#pairs=[ [ '(', ')' ], [ '[', ']' ], [ '{', '}' ] ]
let g:rainbow#colors={
\   'dark': [
\     [ 'darkyellow',  'orangered3'     ],
\     [ 'darkgreen',   'orange2'        ],
\     [ 'blue',        'yellow3'        ],
\     [ 'darkmagenta', 'olivedrab4'     ],
\     [ 'red',         'green4'         ],
\     [ 'darkyellow',  'paleturquoise3' ],
\     [ 'darkgreen',   'deepskyblue4'   ],
\     [ 'blue',        'darkslateblue'  ],
\     [ 'darkmagenta', 'darkviolet'     ]
\   ]
\ }

command! RainbowParenthesesToggle RainbowParentheses!!

" }}}
" plugin: fastfold {{{

let g:fastfold_force=1
let g:fastfold_map=0

" }}}
" plugin: undotree {{{

let g:undotree_WindowLayout=3
let g:undotree_SplitWidth=60
let g:undotree_DiffpanelHeight=20
let g:undotree_SetFocusWhenToggle=1

nnoremap <leader>U :UndotreeToggle<cr>

" }}}
" plugin: markdown {{{

let g:markdown_fenced_languages = [ 'css', 'html', 'javascript', 'js=javascript', 'json=javascript', 'bash=sh', 'lua' ]

" }}}
" plugin: delimitmate {{{

let delimitMate_nesting_quotes=[ '"', "'" ]


" }}}
" custom abbrevs {{{

iabbrev <silent> _date <c-r>=strftime("%Y-%m-%d")<cr>
iabbrev <silent> _time <c-r>=strftime("%H:%M")<cr>

function! EatChar(pat)
  let l:c=nr2char(getchar(0))
  return (l:c =~ a:pat) ? "" : l:c
endfunction

function! SpacelessIabbrev(from, to)
  execute "iabbrev <silent> <buffer> " . a:from . " " . a:to . "<c-r>=EatChar('\\s')<cr>"
endfunction

" based on filetype
augroup ft_abbrev
  au!

  au FileType taskpaper :iabbrev <buffer> @tomorrow @due(<c-r>=strftime("%Y-%m-%d", localtime() + 86400)<cr>)

  au FileType javascript
        \ :call SpacelessIabbrev("clog", "console.log") |
        \ :call SpacelessIabbrev("fn", "function")
augroup END

" open help in new vertical split
cnoreabbrev <expr> h ((getcmdtype() == ":" && getcmdpos() <= 2) ? "vert h" : "h")

" }}}
" custom commands {{{

" reload settings
command! ReloadSettings :so $MYVIMRC | :setlocal foldmethod=marker | :AirlineRefresh

" kills trailing whitespaces
command! KillWhitespace :normal :silent! %s/\s\+$//g<cr>

" shows syntax highlight group for element
function! ShowSyntax()
  echo join(map(synstack(line("."), col(".")), "synIDattr(v:val, 'name')"), " > ")
endfunction

command! ShowSyntax :call ShowSyntax()

" destroy all buffers that are not open in any tabs or windows
" https://github.com/artnez/vim-wipeout/blob/master/plugin/wipeout.vim
function! Wipeout(bang)
  " figure out which buffers are visible in tabs
  let l:visible={}

  for t in range(1, tabpagenr("$"))
    for b in tabpagebuflist(t)
      let l:visible[b]=1
    endfor
  endfor

  " close buffers that are loaded and not visible
  let l:tally=0
  let l:cmd="bw"

  if a:bang
    let l:cmd=l:cmd . "!"
  endif

  for b in range(1, bufnr("$"))
    if buflisted(b) && !has_key(l:visible, b)
      let l:tally += 1
      exe l:cmd . " " . b
    endif
  endfor

  echon "Deleted " . l:tally . " buffer" . (l:tally == 1 ? "" : "s")
endfunction

command! -bang Wipeout :call Wipeout(<bang>0)

" open URL in browser
if has("mac")
  function! HandleURL(visual)
    let l:uri = ""

    if a:visual
      let [l:lnum1, l:col1] = getpos("'<")[1:2]
      let [l:lnum2, l:col2] = getpos("'>")[1:2]
      let l:lines = getline(l:lnum1, l:lnum2)
      let l:lines[-1] = l:lines[-1][: l:col2 - (&selection == 'inclusive' ? 1 : 2)]
      let l:lines[0] = l:lines[0][l:col1 - 1:]

      let l:uri = join(l:lines, "\n")
    else
      let l:uri = matchstr(getline("."), "[a-z]*:\/\/[^ >,;]*")
    endif

    if l:uri != ""
      let l:uri = escape(l:uri, "#")

      silent exec "!open '" . l:uri . "'"
      redraw!

      echo "Opening: " . l:uri
    else
      echo "Can't find URI."
    endif
  endfunction

  nnoremap gx :call HandleURL(0)<cr>
  vnoremap gx :call HandleURL(1)<cr>
endif

" proper indentation on i
function! InsertIndent()
  return len(getline(".")) == 0 ? "cc" : "i"
endfunction

nnoremap <expr> i InsertIndent()

" rename current file
function! Rename()
  let l:old_name=expand("%")
  let l:new_name=input("New file name: ", expand("%"), "file")

  if l:new_name != "" && l:new_name != l:old_name
    exec ":saveas " . l:new_name
    exec ":silent !rm " . l:old_name
    redraw!
  endif
endfunction

command! Rename :call Rename()

" tab to space and back
command! TabToSpace :setlocal expandtab | %retab!
command! SpaceToTab :setlocal noexpandtab | %retab!

" location jumps
function! LocationPrevious()
  try
    lprev
  catch
    try | llast | catch | endtry
  endtry
endfunction

function! LocationNext()
  try
    lnext
  catch
    try | lfirst | catch | endtry
  endtry
endfunction

" jump to errors
nnoremap <leader>e :call LocationNext()<cr>
nnoremap <leader>E :call LocationPrevious()<cr>

" makes * and # work in visual mode
function! VisualSearch(cmdtype)
  let l:temp=@s
  normal! gv"sy
  let @/='\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
  let @s=l:temp
endfunction

" select in visual mode, star, and don't move unles n/N/...
xnoremap * :<c-u>let star_view=winsaveview()<cr>:<c-u>call VisualSearch('/')<cr>/<c-r>=@/<cr><cr>:call winrestview(star_view)<cr>
xnoremap # :<c-u>let hash_view=winsaveview()<cr>:<c-u>call VisualSearch('?')<cr>?<c-r>=@/<cr><cr>:call winrestview(hash_view)<cr>

" }}}
" custom mappings {{{

" expand %% to directory of current file in command-line mode
cnoremap %% <c-r>=fnameescape(expand("%:~:h"))<cr>/

" tab as %
map <tab> %

" input mode mappings
inoremap <c-a> <c-o>0
inoremap <c-e> <c-o>$

" proper movement
nnoremap <Left>  <nop>
nnoremap <Right> <nop>
nnoremap <Up>    <nop>
nnoremap <Down>  <nop>
inoremap <Left>  <nop>
inoremap <Right> <nop>
inoremap <Up>    <nop>
inoremap <Down>  <nop>

" key repeat hack for resizing splits
nmap <c-w>+ <c-w>+<sid>ws
nmap <c-w>- <c-w>-<sid>ws
nmap <c-w>> <c-w>><sid>ws
nmap <c-w>< <c-w><<sid>ws
nnoremap <script> <sid>ws+ <c-w>+<sid>ws
nnoremap <script> <sid>ws- <c-w>-<sid>ws
nnoremap <script> <sid>ws> <c-w>><sid>ws
nnoremap <script> <sid>ws< <c-w><<sid>ws
nmap <sid>ws <nop>

" move by screen lines using arrow, unless it's with number
nnoremap <expr> k (v:count ? "k" : "gk")
nnoremap <expr> j (v:count ? "j" : "gj")

" quicker indentation
nnoremap > >>
nnoremap < <<

" dont loose selection on indenting
vnoremap > >gv
vnoremap < <gv

" sorting in visual mode
vnoremap <leader>s :sort<cr>

" dot works in visual selection mode!
vnoremap . :norm .<cr>

" D deletes to the end of the line
nnoremap D d$

" Y yanks to the end of the line
nnoremap Y y$

" better line begin (H) and end (L)
noremap H ^
noremap L $
vnoremap L g_

" split line
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>

" don't move on * and #
nnoremap <silent> * :let star_view=winsaveview()<cr>*:call winrestview(star_view)<cr>
nnoremap <silent> # :let hash_view=winsaveview()<cr>*:call winrestview(hash_view)<cr>

" disable EX mode and other accidental q* commands
nnoremap q/ <nop>
nnoremap q: <nop>
nnoremap q? <nop>

" disable man pages
nnoremap K <nop>
vnoremap K <nop>

" apply macros with Q
nnoremap Q @q
vnoremap Q :norm @q<cr>

" open common files
nnoremap <leader>ov :e ~/.vimrc<cr>
nnoremap <leader>oz :e ~/.zshrc<cr>

if has("mac")
  nnoremap <leader>od :e ~/Dropbox/Notes/drafts.txt<cr>
  nnoremap <leader>ot :e ~/Dropbox/Tasks/Current.taskpaper<cr>
endif

" open file in current directory
nnoremap <leader>of :e <c-r>=expand("%:p:h") . "/"<cr>

" source vimrc
nnoremap <leader>sv :ReloadSettings<cr>

" run with make
nnoremap <leader>m :wa<cr>:silent make!<cr>:redraw!<cr>

" run current line in shell
nnoremap <leader>rs yyp!!sh<cr>

" save and diff changes
nnoremap <leader>w :w !diff % -<cr>

" buffers
nnoremap gb :bnext<cr>
nnoremap gB :bprev<cr>
nnoremap <leader>bd :bdelete!<cr>
nnoremap <leader>B  :enew<cr>

" new tab
nnoremap <leader>T :tabnew<cr>

" select whole buffer
nnoremap <leader>va ggVG

" select last paste in visual mode
nnoremap <leader>vp "`[" . strpart(getregtype(), 0, 1) . "`]"

" yank whole buffer
nnoremap <leader>ya :let yank_view=winsaveview()<cr>ggyG<cr>:call winrestview(yank_view)<cr>

" paste from system clipboard
nnoremap <leader>p "+p<cr>

" close everything but current fold
nnoremap <leader>ff :setlocal foldlevel=0<cr>zf<cr>

" kill whitespace
nnoremap <silent> <leader>k :let kill_view=winsaveview()<cr>:KillWhitespace<cr>:nohlsearch<cr>:call winrestview(kill_view)<cr>

" clean current search
nnoremap <silent> <leader>c :nohlsearch<cr>

" toggle list chars
nnoremap <silent> <leader>l :set list!<cr>

" toggle numbers
nnoremap <silent> <leader>n :set number!<cr>

" align block
nnoremap <leader>a :let align_view=winsaveview()<cr>=i}<cr>:call winrestview(align_view)<cr>

" center on cursor using scrollof
nnoremap <silent> <leader>z :let &scrolloff=999-&scrolloff<cr>

" }}}
