" neobundle {{{
if has('vim_starting')
	set runtimepath+=~/.vim/bundle/neobundle.vim/
endif
call neobundle#rc(expand('~/.vim/bundle/'))
NeoBundleFetch 'Shougo/neobundle.vim'

" nicer editing bundles
NeoBundle 'tpope/vim-surround'
NeoBundle 'tpope/vim-repeat'
NeoBundle 'tpope/vim-commentary'
NeoBundle 'thinca/vim-visualstar'
NeoBundle 'ervandew/supertab'
NeoBundle 'Raimondi/delimitMate'

" probably unnecessary, but nice to have
NeoBundle 'bling/vim-airline'
NeoBundleLazy 'junegunn/goyo.vim', { 'autoload': { 'commands': 'Goyo' } }

" load this only on OSX
if system("uname -s") == "Darwin\n"
	NeoBundle 'sjl/tslime.vim'
	NeoBundle 'airblade/vim-gitgutter'
	NeoBundle 'scrooloose/syntastic'
endif

" shugo bundles
NeoBundleLazy 'Shougo/unite.vim', {
			\		'autoload': {
			\			'commands': 'Unite'
			\		},
			\		'depends': 'Shougo/vimproc'
			\ }
NeoBundleLazy 'Shougo/vimfiler.vim', {
			\		'autoload': {
			\			'commands': [ 'VimFiler', 'VimFilerExplorer' ],
			\			'explorer': 1
			\		}
			\ }
NeoBundleLazy 'Shougo/vimproc', {
			\		'build': {
			\			'mac': 'make -f make_mac.mak',
			\			'unix': 'make -f make_unix.mak',
			\		},
			\ }

" custom syntax bundles
NeoBundleLazy 'tikhomirov/vim-glsl', { 'autoload': { 'filename_patterns': [ '\.frag$', '\.vert$', '\.glsl$' ] } }
NeoBundleLazy 'sudar/vim-arduino-syntax', { 'autoload': { 'filename_patterns': '\.ino$' } }
NeoBundleLazy 'sophacles/vim-processing', { 'autoload': { 'filename_patterns': '\.pde$' } }
NeoBundleLazy 'plasticboy/vim-markdown', { 'autoload': { 'filetypes': [ 'markdown' ] } }
NeoBundleLazy 'pangloss/vim-javascript', { 'autoload': { 'filetypes': [ 'javascript' ] } }
NeoBundleLazy 'moll/vim-node', { 'autoload': { 'filetypes': [ 'javascript' ] } }
NeoBundleLazy 'kchmck/vim-coffee-script', { 'autoload': { 'filename_patterns': '\.coffee$' } }
NeoBundleLazy 'jelera/vim-javascript-syntax', { 'autoload': { 'filetypes': [ 'javascript' ] } }
NeoBundleLazy 'groenewege/vim-less', { 'autoload': { 'filename_patterns': '\.less$' } }
NeoBundleLazy 'davidoc/taskpaper.vim', { 'autoload': { 'filename_patterns': '\.taskpaper$' } }
NeoBundleLazy 'briancollins/vim-jst', { 'autoload': { 'filename_patterns': [ '\.tpl$', '\.ejs$' ] } }

" }}}
" vim settings {{{

" make vim more useful
set nocompatible

" automaticaly cd into dir
" set autochdir
" autocmd BufEnter * silent! lcd %:p:h

" yank and paste with system clipboard
set clipboard=unnamed

" watch for file changes
set autoread

" redraw only when needed and fast tty
set lazyredraw
set ttyfast
set ttyscroll=3

" don't beep
set noeb vb t_vb=

" disable startup message
set shortmess+=I

" syntax coloring
syntax enable

" don't try to highlight longer lines
set synmaxcol=1024

" encoding
set encoding=utf-8
set fileencodings=utf-8

" indentation
filetype plugin indent on
set autoindent
set tabstop=2
set shiftwidth=2
set softtabstop=2

" html indent fixes
let g:html_indent_inctags="p,li,ol,ul,div,head,html,body,style,script"

" additional settings
set backspace=indent,eol,start
set number
set linebreak
set ruler
set scrolloff=3

" hidden chars liketextmate, disabled by default
set list
" set listchars=tab:â–¸\ ,trail:âˆ™,eol:Â¬
set listchars=tab:â–¸\ ,trail:âˆ™

" buffers/tabs settings
set switchbuf=useopen,usetab,newtab
set hidden

" no backups or swapfiles, with centralized and persistent undo history
set nobackup
set noswapfile
set undofile
set undodir=~/.vim/undo//

" fix for node fs.watch
set backupcopy=yes

" long history and undo
set history=1000
set undolevels=1000
set undoreload=10000

" search settings
set hlsearch
set ignorecase
set smartcase
set incsearch

" always disaplay status line
set laststatus=2

" show tabline only when needed
set showtabline=1

" don't show current mode/cmd
set noshowmode
set noshowcmd

" completion in command line
set wildmenu

" insert completion height
set pumheight=10

" code folding
set foldmethod=syntax
set foldlevel=999
set foldcolumn=0

" color theme
set t_Co=256
set background=dark

let g:solarized_bold=0
let g:solarized_italic=0
let g:solarized_underline=0
colorscheme solarized
" colorscheme tomorrow-night

" open splits to the right and bottom
set splitright
set splitbelow

" fillchars with nice utf8 vert split, and no fold char
set fillchars=fold:\ ,vert:â”‚

" extended % matching
runtime macros/matchit.vim

" set path
if system('uname')=="Darwin\n"
	let $PATH="/usr/local/bin:" . $PATH . ":/Users/Szymon/Dropbox/Code/Scripts"
endif

" }}}
" autocommands {{{

" return to same line after reopenning file
augroup line_return
	au!
	au BufReadPost *
		\ if line("'\"") > 0 && line("'\"") <= line("$") |
		\		execute 'normal! g`"zvzz' |
		\ endif
augroup END

" automatically resize splits when resizing window
augroup split_resize
	au!
	au VimResized * wincmd =
augroup END

" set proper syntaxes
augroup syntaxes
	au!

	" proper filetypes based on name
	au BufNewFile,BufRead *.mm        set filetype=objc
	au BufNewFile,BufRead *.tpl       let b:jst_subtype='html' | set filetype=jst
	au BufNewFile,BufRead *.md        set filetype=markdown
	au BufNewFile,BufRead *.ino       set filetype=arduino
	au BufNewFile,BufRead *.pde       set filetype=processing
	au BufNewFile,BufRead *.frag      set filetype=glsl
	au BufNewFile,BufRead *.vert      set filetype=glsl
	au BufNewFile,BufRead *.glsl      set filetype=glsl
	au BufNewFile,BufRead *.taskpaper set filetype=taskpaper
	au BufNewFile,BufRead ~/Dropbox/Notes/* setlocal filetype=markdown

	" extend highlights
	au Syntax * call matchadd('Todo','\W\zs\(ASSUMPTION\)')
augroup END

" custom settings based on filetype
augroup ft_settings
	au!

  " au FileType javascript call JavaScriptFold()
	au FileType coffee setlocal shiftwidth=2 expandtab
	au FileType vim setlocal foldmethod=marker foldlevel=0
	au FileType taskpaper call taskpaper#fold_projects()
augroup END

" no numbers / special chars based on file types
augroup plain_filetypes
	au!

	au FileType vimfiler  setlocal nonumber | setlocal nolist
	au FileType text      setlocal nonumber | setlocal nolist
	au FileType markdown  setlocal nonumber | setlocal nolist
	au FileType taskpaper setlocal nonumber | setlocal nolist
augroup END

" cursorlines in special buffers
augroup cursorlines
	au!

	au FileType vimfiler setlocal cursorline
augroup END

" }}}
" window titles {{{

" set nice window title
function! DirPath()
	let l:splited = split(expand("%:p"), "/")
	let l:cut = 3
	if len(l:splited) < l:cut
		let cut = len(l:splited)
	endif

	let l:cut = -l:cut

	if len(l:splited) == 0
		return "[No Name]"
	else
		return join(l:splited[l:cut : -1], "/")
	endif
endfunction

function! WindowTitle()
	return "vim: " . DirPath()
endfunction

" set title on start as simple 'vim'
set title
set titlestring=vim

" update titlestring with proper title
augroup title_titlestring
	au!
	au BufEnter * let &titlestring = WindowTitle()
augroup END

" only needed in screen
if &term == "screen-256color"
	" screen caption is set by iconstring
	set t_IS=k
	set t_IE=\
	set icon

	augroup title_iconstring
		au!
		au BufEnter * let &iconstring = WindowTitle()
	augroup END

	" screen window title is set by titlestring
	set t_ts=]2;
	set t_fs=\
endif

" }}}
" plugin: airline {{{

" airline settings
let g:airline_left_sep=''
let g:airline_right_sep=''
let g:airline_inactive_collapse=0
let g:airline#extensions#whitespace#enabled=0
let g:airline#extensions#syntastic#enabled=0
let g:airline#extensions#hunks#enabled=0
let g:airline_section_b="%{DirPath()}"
let g:airline_section_c="%t"
let g:airline_section_x=""
let g:airline_section_y=""

" show tabline themed with airline only when needed
if !has("gui_running")
	let g:airline#extensions#tabline#enabled=1
	let g:airline#extensions#tabline#show_buffers=0
	let g:airline#extensions#tabline#show_tab_type=0
	let g:airline#extensions#tabline#tab_min_count=2
	let g:airline#extensions#tabline#show_tab_nr=0
	let g:airline#extensions#tabline#left_sep=''
	let g:airline#extensions#tabline#left_alt_sep=''
	let g:airline#extensions#tabline#right_sep=''
	let g:airline#extensions#tabline#right_alt_sep=''
endif

" remove bold fonts from airline tomorrow theme
let g:airline_theme_patch_func = 'AirlineThemePatch'
function! AirlineThemePatch(palette)
	if g:airline_theme == 'tomorrow' || g:airline_theme == "solarized"
		let palettes = [a:palette.normal, a:palette.insert, a:palette.replace, a:palette.visual, a:palette.accents]

		for palette in palettes
			for colors in values(palette)
				if len(colors) >= 5
					let colors[4] = 'none'
				endif
			endfor
			" let palette.airline_c[3] = '0'
		endfor

		if g:airline_theme == 'tomorrow' && !has("gui_running")
			for colors in values(a:palette.inactive)
				let colors[2] = '245'
				let colors[3] = '0'
			endfor
		endif

		if g:airline_theme == 'solarized'
			for colors in values(a:palette.inactive)
				if &background == "dark"
					let colors[0] = '#586e75'
					let colors[1] = '#073642'
				else
					let colors[0] = '#93a1a1'
					let colors[1] = '#eee8d5'
				endif
				let colors[2] = '10'
				let colors[3] = '0'
			endfor
		endif
	endif
endfunction

" }}}
" plugin: syntastic {{{

let g:syntastic_enable_highlighting=0
let g:syntastic_check_on_open=1
let g:syntastic_check_on_wq=0
let g:syntastic_always_populate_loc_list=1
let g:syntastic_error_symbol='!'
let g:syntastic_style_error_symbol='!'
let g:syntastic_warning_symbol='?'
let g:syntastic_style_warning_symbol='?'

" }}}
" plugin: supertab {{{

let g:SuperTabDefaultCompletionType="context"
let g:SuperTabContextDefaultCompletionType="<c-n>"

" }}}
" plugin: unite {{{

" settings
let g:unite_data_directory=expand('~/.vim/unite')
let g:unite_source_history_yank_enable=1
let g:unite_cursor_line_time=0
let g:unite_cursor_line_highlight='CursorLine'

call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])

" mappings
nnoremap <silent> <C-p> :Unite -buffer-name=files -start-insert file_rec/async:!<cr>
nnoremap <silent> <C-b> :Unite -buffer-name=buffer -start-insert buffer<cr>
nnoremap <silent> <C-y> :Unite -buffer-name=yank -start-insert history/yank<cr>

" grep
if executable('ag')
	let g:unite_source_grep_command='ag'
	let g:unite_source_grep_default_opts=
	  \ '--line-numbers --nocolor --nogroup --ignore-case --hidden --ignore ' .
	  \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
	let g:unite_source_grep_recursive_opt=''
	nnoremap <silent> <C-g> :Unite -buffer-name=grep -no-quit -keep-focus -no-start-insert grep:.<cr>
endif

" NV notes
if isdirectory($HOME . "/Dropbox/Notes")
	command! -nargs=* Notes :silent Unite -buffer-name=notes -start-insert file_rec/async:~/Dropbox/Notes -input=<args>
endif

" TaskPaper tasks
if isdirectory($HOME . "/Dropbox/Tasks")
	command! -nargs=* Tasks :silent Unite -buffer-name=tasks -start-insert file_rec/async:~/Dropbox/Tasks -input=<args>
endif

" }}}
" plugin: vimfiler {{{

let g:vimfiler_enable_auto_cd=1
let g:vimfiler_as_default_explorer=1
let g:vimfiler_directory_display_top=1
let g:vimfiler_tree_leaf_icon=' '
let g:vimfiler_tree_opened_icon='â–¾'
let g:vimfiler_tree_closed_icon='â–¸'
let g:vimfiler_file_icon=' '
let g:vimfiler_marked_file_icon='*'
let g:vimfiler_data_directory=expand('~/.vim/vimfiler')

" open vimfilerexplorer
nnoremap <silent> <C-n> :VimFilerExplorer<cr>
nnoremap <silent> <C-f> :VimFiler<cr>

" open files with enter
autocmd FileType vimfiler nmap <buffer><silent> <Enter>
			\ :<C-u>execute "normal " . vimfiler#mappings#smart_cursor_map(
			\  "\<Plug>(vimfiler_cd_file)",
			\  "\<Plug>(vimfiler_edit_file)")<CR>

" }}}
" plugin: vimproc {{{

" simple app running functions
command! Plask :VimProcBang plask %
command! Node :VimProcBang node %

" }}}
" plugin: tslime {{{

let g:tslime_ensure_trailing_newlines = 1

" }}}
" plugin: goyo {{{

command! Zen :Goyo

" }}}
" custom commands {{{

" kills trailing whitespaces
command! KillWhitespace :normal :%s/\s\+$//g<cr>

" shows syntax highlight group for element
command! ShowSyntax
			\ :echo "hi<".synIDattr(synID(line("."),col("."),1),"name").'>'
			\ . ' trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
			\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"
			\ <cr>:execute "highlight " .
			\ synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")<cr>

" destroy all buffers that are not open in any tabs or windows
" https://github.com/artnez/vim-wipeout/blob/master/plugin/wipeout.vim
command! -bang Wipeout :call Wipeout(<bang>0)
function! Wipeout(bang)
	" figure out which buffers are visible in any tab
	let visible = {}
	for t in range(1, tabpagenr('$'))
		for b in tabpagebuflist(t)
			let visible[b] = 1
		endfor
	endfor
	" close any buffer that are loaded and not visible
	let l:tally = 0
	let l:cmd = 'bw'
	if a:bang
		let l:cmd .= '!'
	endif
	for b in range(1, bufnr('$'))
		if buflisted(b) && !has_key(visible, b)
			let l:tally += 1
			exe l:cmd . ' ' . b
		endif
	endfor
	echon "Deleted " . l:tally . " buffer" . (l:tally == 1 ? "" : "s")
endfun

" open URL in browser
if system("uname -s") == "Darwin\n"
	function! s:OpenURL(url)
		echo a:url
		exe "!open \"" . a:url . "\""
		redraw!
	endfunction

	command! -nargs=1 OpenURL :call s:OpenURL(<q-args>)

	nnoremap gb :OpenURL <cfile><cr>
endif

" toggle background
function! ToggleBackground()
	if &background == "dark"
		set background=light
	else
		set background=dark
	endif
endfunction
command! ToggleBackground :call ToggleBackground()

" visual selection function
function! VisualSelection(direction) range
	let l:saved_reg = @"
	execute "normal! vgvy"

	let l:pattern = escape(@", '\\/.*$^~[]')
	let l:pattern = substitute(l:pattern, "\n$", "", "")

	if a:direction == 'b'
		execute "normal ?" . l:pattern . "^M"
	elseif a:direction == 'gv'
		call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
	elseif a:direction == 'replace'
		call CmdLine("%s" . '/'. l:pattern . '/')
	elseif a:direction == 'f'
		execute "normal /" . l:pattern . "^M"
	endif

	let @/ = l:pattern
	let @" = l:saved_reg
endfunction

" visual mode pressing * or # searches for the current selection
vnoremap <silent> * :call VisualSelection('f')<cr>
vnoremap <silent> # :call VisualSelection('b')<cr>

" motion for 'next' and 'last' text object
" from: https://gist.github.com/sjl/3762227
onoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>

function! s:NextTextObject(motion, dir)
  let c = nr2char(getchar())

  if c ==# "b"
      let c = "("
  elseif c ==# "B"
      let c = "{"
  elseif c ==# "r"
      let c = "["
  endif

  exe "normal! ".a:dir.c."v".a:motion.c
endfunction

" }}}
" custom mappings {{{

" stop command line from showing accidentaly
map q: :q

" dont loose selection on indenting
vnoremap > >gv
vnoremap < <gv

" dot works in visual selection mode!
vnoremap . :norm.<cr>

" move by screen lines using arrow
nnoremap <Up> gk
nnoremap <Down> gj
inoremap <expr> <Down> pumvisible() ? "<Down>" : "<C-O>gj"
inoremap <expr> <Up> pumvisible() ? "<Up>" : "<C-O>gk"

" select whole buffer
nnoremap <silent> <leader>va ggVG

" move between windows
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap <C-h> <C-w>h

" tabs mappings
nnoremap <leader>tn :tabnext<cr>
nnoremap <leader>tp :tabprev<cr>
nnoremap <leader>tc :tabclose<cr>
nnoremap <leader>tN :tabnew<cr>

" buffer mappings
nnoremap <leader>bn :bnext<cr>
nnoremap <leader>bp :brevious<cr>
nnoremap <leader>bd :bdelete<cr>
nnoremap <leader>bN :new<cr>

" D deletes to the end of the line
nnoremap D d$

" better line begin (H) and end (L)
noremap H ^
noremap L $
vnoremap L g_

" don't move on *
nnoremap <silent> * :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>

" keep search matches in the middle of the window
nnoremap n nzzzv
nnoremap N Nzzzv

" same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz
nnoremap <c-o> <c-o>zz

" disable EX mode
nnoremap Q <nop>

" kill whitespace
nnoremap <silent> <leader>k :KillWhitespace<cr>:nohlsearch<cr>

" clean current search
nnoremap <silent> <leader>c :nohlsearch<cr>

" toggle list chars
nnoremap <silent> <leader>l :set list!<cr>

" toggle numbers
nnoremap <silent> <leader>n :set number!<cr>

" switch cwd to the directory of the open buffer
nnoremap <silent> <leader>d :cd %:p:h<cr>

" }}}
